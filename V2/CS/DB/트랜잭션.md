# 트랜잭션에 대한 모든 것

### 순서
1. 트랜잭션이 뭔가요?
2. 트랜잭션이 필요한 이유
3. 트랜잭션의 특징 - ACID
4. 트랜잭션의 진행 상태
5. 트랜잭션 연산
6. 원자성 - 트랜잭션 처리 도중 실패 시에는 어떻게?
    - 회복 => UNDO(롤백과 같다고 볼 수 있음), REDO, Check Point
7. 일관성 - Lock
    - Blocking
    - DeadLock
8. 격리성 - 트랜잭션의 고립 수준

<br><br>

### **트랜잭션이란?**  
데이터베이스의 상태를 변화시키는 *논리적 기능을 수행하기 위한 작업의 단위*  
> 함께 이루어지는 작업들의 제어 및 실패 시 회복 작업을 함  

<br><br>

### **트랜잭션이 필요한 이유**  
- 데이터의 일관성을 유지하면서 안정적으로 데이터를 복구하기 위함.
- ex) 은행의 송금 시스템
    - A계좌에서는 돈이 빠져나가고 B계좌에서는 돈이 들어와야함.
    - 빠져나가고 들어오는 것을 한번에 처리
    - 오류가 나면 안정적으로 되돌려야함.  

<br><br>

### **트랜잭션의 특징**  
- **Atomicity(원자성)**
    - 트랜잭셔이 모두 반영되던가 반영되지 않던가
- **Consistency(일관성)**
    - 트랜잭션 처리 결과가 항상 동일 해야함
    - 어떤 쿼리에서는 다른 값을 내뿜으면 안됨
- **Isolation(독립성 or 고립성 or 격리성)**
    - 트랜잭션이 병행 실행되고 있을때 두 연산의 서로 끼어들 수 없다.
- **Durabilty(영구성)**
    - 트랜잭션이 성공적으로 완료되면 결과는 영구적으로 반영되어야 함.  

<br><br>

### **트랜잭션의 진행 상태**
1. Active(활동) - 실행중인 상태, 연산들이 정상적으로 실행 중
2. Failed(실패) - 실행에 오류가 발생하여 중단
3. Aborted(철회) - 비정상적으로 종료되어 Rollback 연산을 수행한 상태
4. Partially Committed(부분적 완료) - 아직 작성한 것들을 저장하지 않은 상태
5. Committed(완료) - 성공적으로 종료되어 Commit 연산을 실행한 후의 상태  

<br><br>

### **트랜잭션 연산**  
DML(INSERT, UPDATE), DDL(CREATE, ALTER, DROP), DCL(GRANT, REVOKE) 문장이 실행됐을 때 트랜잭션 시작  
DDL, DCL은 트랜잭션이 자동으로 종료  
DML 같은 경우 Commit, Rollback으로 종료해야함.  
1. **Commit**
    - 하나의 트랜잭션이 성공적으로 끝남, DB가 일관된 상태일 때 연산 완료를 알려주기 위한 연산
2. **Rollback**
    - 하나의 트랜잭션 처리가 비정상적으로 종료되어 일관성을 깨뜨리면, 행한 모든 연산을 취소하는 연산(Undo)
    - 트랜잭션 내에서 에러 -> Rollback
    - 시스템 오류같은 외부 요인 -> 회복  

<br><br>

### **원자성 - 회복방법**  
시스템 오류와 같은 외부 요인으로 에러가 발생했을 때 회복.
1. **Undo**
    - 원상태로 되돌림
    - 사용자가 했던 작업을 반대로 진행해 원상태로 되돌림
2. **Redo**
    - 이미 commit한 수정을 재반영하는 복구
    - 이전 상태로 되돌리고 실패가 발생하기 전까지의 과정을 그대로 따라감
    - 그러기 위해 과정을 기록해야함 - log
3. **Check Point**
    - 설정한 지점 이전까지는 트랜잭션이 성공적으로 수행 -> disk에 확실히 저장된 상태  
    - 회복하기 위해 돌아갈 때, 너무 많이 돌아가지 않도록 하기 위함  

<br><br>

### **일관성 Lock**  
데이터의 일관성을 보장하기 위한 방법. (트랜잭션 처리의 순차성을 보장하는 방법)  
- Share Lock
    - 데이터 읽기에 사용되어지는 Lock
    - 다른 사용자가 볼 수 있지만 변경은 불가
- Exclusive Lock
    - 데이터 변경하고자 할 때 사용되어지는 Lock
    - 트랜잭션이 완료될 때가지 유지
    - 해당 Lock이 해제되기 전까지 다른 트랜잭션은 해당 리소스에 접근 불가  

**Blocking**  
- Lock간의 경합이 발생해 특정 트랜잭션 작업을 진행하지 못하고 멈춰선 상태  
- 베타락이 블로킹을 발생시킴
- 이전 트랜잭션이 완료되어야 진행이 가능함. 
- 격리레벨을 상향 조정하지 않기, 트랜잭션 길이 길게하지 말기, 애초부터 동시수행되지 않게 설계하기  

**교착상태**  
두 트랜잭션이 각각 Lock을 설정하고 각각이 서로의 Lock에 접근하게 되면 처리하지 못하고 대기하게된다. 둘 다 접근하지 못하므로 영원히 처리하지 못하는 상태가 됨.  
접근순서를 정함으로써 해결이 가능.  

<br><br>

### **격리성 - 트랜잭션 격리 레벨**  
실행중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다. -> 접근 레벨이 있고 설정이 가능함.  

**격리성으로 인한 문제점**  
1. Dirty Read
    - 수정되었지만 커밋하지 않은 데이터를 읽는 것
    - 커밋되지 않고 Rollback이 될 경우 잘못된 값을 읽는 문제가 발생
2. Non-Repeatable Read
    - 한 트랜잭션에서 같은 Key를 가진 Raw를 두 번 읽었는데 그 사이에 값이 변경/삭제 되어 결과가 다른 현상
    - 한 개의 값이 변경
3. Phantom Read
    - 한 트랜잭션에서 같은 query를 두 번 수행 시, 두 번째에서 없던 레코드가 나타나는 현상
    - 여러건을 요청하는 것에 대해 값이 변경  

**지정 가능한 격리성 수준**  
- 0레벨 - Read Uncommitted
    - 트랜잭션 처리 중 아직 커밋되지 않은 데이터 읽기 허용
    - 위의 3가지 문제점이 전부 나타나게 됨
- 1레벨 - Read Committed
    - 트랜잭션이 확정된 데이터만 다른 트랜잭션이 읽기 허용
    - 커밋되지 않은 데이터는 Undo 로그에 있는 이전 데이터를 가져오는 것
    - Dirty Read만 막을 수 있음.
- 2레벨 - Repeatable Read
    - 트랜잭션 내에서 삭제,변경은 바로 Undo 로그에 넣어둠
    - 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo 로그에 있는 데이터를 읽음
    - Non-Repeatable Read까지 해소 가능함.
- 3레벨 - Serialized Read
    - 트랜잭션 내에서 쿼리를 두 번 이상 수행 시 새로운 레코드가 나타나거나 기존 레코드가 삭제,변경되는 것 모두 막음  

**격리성 수준 선택시 고려사항**  
- 동시성과 무결성과 관련되어있음.
- 동시성을 증가시키면 무결성에 문제가 생기고 그 역의 상황도 발생함.
- 더 빠른 실행을 원한다면 동시성을 더 정확한 실행을 원한다면 무결성을 가져갈 수 있음.  

**트랜잭션 처리에 시간이 오래걸리는데 API호출 시 어떻게 할까?**
- 클라에서 비동기 통신을 사용
