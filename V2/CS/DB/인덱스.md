# 인덱스

### **순서**
1. 인덱스란?
2. 인덱스를 사용하는 이유
3. 인덱스의 단점
4. 인덱스를 효율적으로 관리
5. 어떤 값으로 인덱스를 생성하면 좋을까
6. 인덱스 테이블을 구현하는 자료구조

### **인덱스란?**  
테이블에 대한 검색 성능의 속도를 높여주는 자료구조  
**어떤 방식으로 동작하는가**  
1. 컬럼의 인덱스가 생성되면 -> 해당 컬럼 데이터 정렬해 별도의 메모리 공간에 물리적 주소와 함께 저장됨
2. where 조건을 거는 등의 작업을 하면 `옵티마이저`에서 판단하여 생성된 인덱스를 탈수 있음
3. 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 검색 속도를 향상시켜줌  

<br><br>  

### **인덱스를 사용하는 이유**  
**인덱스를 사용하지 않으면**
- 테이블 안에 데이터가 쌓이면 레코드는 내부적으로 순서가 없이 뒤죽박죽 저장됨.  
- 모든 레코드의 처음부터 끝까지 읽어서 검색 조건과 맞는지 비교 -> 풀 테이블 스캔  

**인덱스 사용**  
- 데이터들이 정렬되어 있음. 조건에 맞는 데이터 찾기가 빠름  
- Order by 절의 효율성을 가짐 -> 이미 정렬되어 있기 때문에  
- MIN, MAX를 효율적인 처리가 가능 -> 이미 정렬되어 있기 때문에  

<br><br>  

### **인덱스 단점**  
- 정렬된 상태를 계속 유지 시켜줘야한다는 점
    - 데이터의 값이 바뀔때 악영향
    - 추가, 삭제, 수정 시 값이 변경되어 재정렬 해야함
    - 원본 테이블, Index 테이블 둘 다 수정 해줘야함
- 인덱스를 관리하기 위해서 데이터베이스의 10%에 해당하는 추가 저장공간이 필요
- 테이블 전체 데이터 중 10~15%이하의 데이터를 처리할 때 효율적
    - 그 이상은 풀 테이블 스캔이 더 좋다는 뜻

<br><br>  

### **인덱스를 효율적으로 관리**  
인덱스는 항상 정렬된 상태를 유지해야 빠른 탐색이 가능하다.  
삽입,수정,삭제가 수행된다면 계속 정렬을 해줘야 하고 부하가 발생된다.  
이런 부하를 최소화하기 위해 '데이터 삭제' -> index를 사용하지 않는다라는 뜻으로 이용.  
Update 또한 기존 인덱스를 사용하지 않고, 갱신된 데이터에 인덱스를 추가함.  

<br><br>  

### **어떤 값으로 인덱스를 생성하면 좋을까**  
1. 조건절에 자주 등장하는 컬럼
2. 항상 =으로 비교되는 컬럼
3. 유니크한 컬럼
4. Order By 절에서 자주 사용되는 컬럼
5. 조인 조건으로 자주 사용되는 컬럼  

<br><br>  

### **인덱스 테이블을 구현하는 자료구조**  
**B트리 개열 - B트리, B+트리**  
- 하나의 노드에 여러자료가 배치되는 트리구조
- M차 B트리 -> 자식노드가 최대 M개
- 스스로 균형을 맞추는 트리

B트리는 순회 작업이 난감함.  
순차접근에 대한 문제의 히결책으로 leaf 노드끼리 linked list로 이어져있다.  
범위 탐색에 유리해 졌다.  
  
단점으로 B Tree의 경우 베스트는 루트에서 끝나지만 B+트리는 무조건 leaf노드 까지 가야한다.