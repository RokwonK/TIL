# HTTP의 특징과 역사

HTTP는 여러 버전을 거치며 진화해왔고 당연한 듯 사용했지만 제대로 정의된 특징을 가지고 있다. 자세히 알아보자.

HTTP는 Hyper Text Transfer Protocol의 약자로 **인터넷에서 데이터를 주고받을 수 있는 프로토콜**이다. 조금 더 자세히 설명하자면 **클라이언트와 서버가 인터넷을 통해 텍스트, json, 이미지와 같은 정보를 주고받을 수 있도록 하는 것**이다.

> **💡 프로토콜**
프로토콜은 통신 규약이다. 보내는 쪽과 받는 쪽이 서로 이해할 수 있도록 해석방법을 정의한 약속이라고 할 수 있다.

<br /><br />

## HTTP의 특징
### client - server 구조

서버는 비지니스 로직과 데이터를 처리하며 클라이언트는 UI와 유저 사용성에 중심을 둔다.
역할이 구분되어 있기에 각각이 독립적으로 진화할 수 있다.
이 구조에서 클라이언트는 서버로 **요청메시지**를 보내고 서버는 **응답메시지**를 보낸다.
**요청과 응답의 역할이 나누어져 있으며 요청을 할때만 응답을 받는 단방향 통신**이라는 것이 핵심이다.

### Stateless(무상태)

HTTP통신에 서버는 클라이언트의 상태를 보존하지 않는다.
즉, 클라이언트가 이전에 어떤 요청을 했던지 다음 요청에 영향을 주지 않는다.
이러한 특징은 서버가 확장 가능하다는 장점을 가져올 수 있다.
여러대가 서버가 돌아가는 환경에서 서버끼리 정보를 공유하기가 힘들다. Stateless 사용할 경우 정보 공유를 위한 비용을 최소화할 수 있다.

하지만 인증된 유저를 확인하는 방법과 같이 상태를 유지해야하는 경우가 있다. 이러한 문제점을 해결하기 위해 - 쿠키, 세션, OAuth, JWT와 같은 개념들이 등장했다.

### Connectionless(비연결성)

기본적으로 서버와 클라이언트는 연결을 계속 유지하지 않는다. 서버로 많은 요청이 들어올 때 모든 연결이 그대로 유지되면 서버측 자원이 빠르게 고갈되기 때문이다.
하지만 많은 요청을 한 번에 처리할때 각 요청마다 다시 연결을 하는 것도 손해이다. 이러한 문제점을 해결하기 위해 HTTP/2에서는 keep-alive라는 기능을 도입하였다.

### HTTP 메세지

상태코드, 메서드, 버전, 헤더, 메시지 바디와 같은 구성요소를 가지고 있다.
각 요소들은 의미가 있으며 이를 통해 무엇을 위한 요청/응답인지 알 수 있다.

### 확장 가능

HTTP 자체는 단순하며 메시지 또한 단순한 형태이다.
헤더를 이용하여 확장에도 용이하다.

<br />

---

<br />

## HTTP의 버전별 특징
### HTTP/0.9

- 1991년
- **`GET 메서드`만** 존재
- **`HTML 파일`만** 전송 가능함
- **`상태 코드 X`** - 문제 발생시 오류 HTML 파일을 응답함

### HTTP/1.0

- 1996년
- Method가 GET, HEAD, POST로 확장됨.
- 요청에 HTTP 버전 정보가 들어가기 시작
- **`상태 코드 도입`**
- `**HTTP 헤더 개념이 도입**`, 프로토콜을 유연하고 확장 가능하도록 만들어줌
- `**Content-Type 헤더**`를 이용하여 HTML 파일 외에 다른 문서들을 전송하는 기능이 추가됨

### HTTP/1.1

- 1997년
- OPTION, PUT, DELETE, TRACE Method가 추가됨
- 커넥션을 유지하는 **`keep-alive`** 지원
- `**파이프라이닝**`과 같은 성능 최적화를 도입
    - HOLB(Head Of Line Blocking) 문제 - 선요청이 선응답이 되어야하는 문제
    - 파이프라이닝을 사용하지만 헤더의 중복이 발생한다.
- **`호스트 헤더`**(하나의 IP에 여러 도메인 운영)
    - Host 헤더를 추가를 통해 버츄얼 호스팅 가능해짐
- **`프록시 인증`**(proxy-authentication, proxy-authorization)
    - 서버에서 클라언트 인증을 요구하는 www-authentication 헤더는 1.0부터 지원
    - client-server 사이에 프록시가 위치할때 프록시가 인증을 요구할 방빕을 지원
- 캐시로 성능 향상, 데이터를 압축 전송

### HTTP/2.0

- HTTP 1.X는 평문 → 2.0부터는 바이너리 포맷으로 인코딩된 Message, Frame으로 구성(바이너리로 소통)
- 바이너리 프레이밍 계층 사용 - 파싱, 전송 속도 증가(바이너리로 전달하므로)
- **`멀티플렉스 스트림`**
    - 스트림 우선순위 설정
    - 바이너리 프레임으로 나누고 받는 쪽에서 재조립
    - 요청과 응답의 순서가 중요하지 않음 → HTTP1.1의 HOLB해결
- Server push
    - 클라가 요청하지 않은 리소스도 push 가능
- Header Compression
    - 헤더의 크기를 줄였다(중복 제거)
- TCP의 HOLB 문제가 남아있음
    - 앞의 패킷에 에러가 생긴다면 다음 패킷이 기다려야함(딜레이가 생김)

### HTTP/3.0

- TCP → UDP
    - tcp는 신뢰성을 확보하지만 지연을 줄이기 힘든 구조 - 패킷 구조상 넣을게 많음
    - udp는 패킷 구조가 작음
- TCP 커넥션(핸드쉐이크) 없이 바로 연결, 성공시 설정을 캐싱한다.
- TCP의 HOLB 문제를 해결
- UDP와 QUIC을 이용함
    - 패킷의 구조가 작음
    - TLS를 기본적으로 사용
    - 핸드쉐이크 없이 통신